;;;; This file contains functions needed to invoke a-star-search on an n-queens problem.
;;;;
;;;; n-queens is the function that should be called to solve a puzzle.  Calling it with no parameters will run a 4-queens problem where all queens are placed in the first column of the boqard.
;;;; The following functions are provided to a-star to solve the n-queens problem:
;;;;   1) heuristic - A heuristic function that, given a candidate future state (as generated by generate-child-states), returns a heuristic cost for the potential future state.
;;;;   2) generate-child-states -  A child state generation function that, given a current state, generates all candidate future states that might be chosen as the next state.  This function respects the rules of queen movements in chess.
;;;;   3) g-cost - A cost function that, given the current cost, a current state, and a future state, calculates the total cost of moving from current state to future state.  For n queens, this is simple - each 
;;;;       transition increases the total cost by 1.
;;;;   5) get-printable-state - A print helper function that creates a pretty print string for the given state of the chess board.
;;;;
;;;;


(in-package :cl-user)

;;; This state will be used if no start state is provided when calling puzzle-search
(defparameter *queens-default-start-state* '((0 0) (1 0) (2 0) (3 0)))

;;; IMPORTANT:  To extend print capabilities to more than 4 or 5 queens, the larger board must be defined below for print to work properly.
(defparameter *queens-board-positions-5* '((0 0) (0 1) (0 2) (0 3) (0 4) (1 0) (1 1) (1 2) (1 3) (1 4) (2 0) (2 1) (2 2) (2 3) (2 4) (3 0) (3 1) (3 2) (3 3) (3 4) (4 0) (4 1) (4 2) (4 3) (4 4)))
(defparameter *queens-board-positions-4* '((0 0) (0 1) (0 2) (0 3) (1 0) (1 1) (1 2) (1 3) (2 0) (2 1) (2 2) (2 3) (3 0) (3 1) (3 2) (3 3)))


;;; Returns a boolean indicating if there is a queen in the state at the given location, in (i,j) format.
(defun is-queen-here (state loc)
   (find-if #'(lambda (x) (equalp loc x)) state)
)

;;; Print helper function.  Prints the board given the full board positions and a state
;;; which includes all the queen positions.
(defun queens-print-state-inner (state board)
   (if (not (null board))
       (let ((cur ""))
          (if (is-queen-here state (car board))
             (setf cur (format nil "Q "))
            (setf cur (format nil "x "))
          )
          (if (not (equalp (first (first board)) (first (second board)))) ; print newline for row change
             (setf cur (concatenate 'string cur (format nil "~%")))
          )
          (concatenate 'string cur (queens-print-state-inner state (cdr board)))
       )
    )
)

;;; This print function is used by a-star to print the state of the board.
;;; Given a state, this returns a pretty print representation of the state.
(defun queens-get-printable-state (s)
   (let ((board-positions (if (equal (length s) 4) *queens-board-positions-4* *queens-board-positions-5*)))
      (concatenate 'string (format nil "~%") (queens-print-state-inner s board-positions))
   )
)

;;; Given the full state with all queen locations and a single queen location this
;;; creates all legal moves for the single queen location.
(defun next-moves (fullstate queenloc)
   (let ((i (first queenloc))
         (j (second queenloc))
         (numqueens (- (length fullstate) 1)))
       (let ((allmoves (list (list i (- j 1))
                             (list (- i 1) (- j 1))
                             (list (- i 1) j)
                             (list (- i 1) (+ j 1))
                             (list i (+ j 1))
                             (list (+ i 1) (+ j 1))
                             (list (+ i 1) j)
                             (list (+ i 1) (- j 1)))))
           (remove-if #'(lambda (x) (or
                                       (> (first x) numqueens)
                                       (> (second x) numqueens)
                                       (< (first x) 0)
                                       (< (second x) 0)
                                       (is-queen-here fullstate x))) allmoves)

        )
   )
)

;;; Remove the given queen from the state
(defun remove-queen (state queenloc)
  (remove-if #'(lambda (x) (equalp queenloc x)) (copy-list state))
)

;;; Creates new states given a parent state, the queen to move and all the moves
;;; for the queen to move to.
(defun move-queen (state queenloc moves)
   (if (not (null moves))
      (let ((carmoves (cons (car moves) (remove-queen state queenloc))))
         (cons carmoves (move-queen state queenloc (cdr moves)))
      )
   )
)

;;; Helper function for queens-generate-child-states
(defun queens-generate-child-states-inner (fullstate workingstate)
   (if (not (null workingstate))
       (let ((nextmoves (next-moves fullstate (car workingstate))))
          (append (move-queen fullstate (car workingstate) nextmoves) (queens-generate-child-states-inner fullstate (cdr workingstate)))
       )
   )
)

;;; This function is used by a-star to generate child states from a parent state to keep
;;; the search continuing.
;;; Given a parent state, generates all legal queen  moves from this state (for all queens).
;;; A list of the candidate child states is returned.
(defun queens-generate-child-states (state)
   (queens-generate-child-states-inner state (copy-list state))
)

;;; Returns a count of the number of queen threats on the board.
;;; Two queens threatening each other is counted as 2.
(defun queens-is-threat-count (queen1 otherqueens)
  ; add up for all 4 potential threat vectors
   (if (not (null otherqueens))
      (let ((queen2 (car otherqueens)))
         (let ((queen1i (first queen1))
               (queen1j (second queen1))
               (queen2i (first queen2))
               (queen2j (second queen2)))
            (if (or (equalp queen1i queen2i) ; horizontal
                (equalp queen1j queen2j) ; vertical
                (equalp (abs (- queen1i queen2i)) (abs (- queen1j queen2j)))) ; diagonals
                  (+ 1 (queens-is-threat-count queen1 (cdr otherqueens))) ; count threat of car and continue on
              (queens-is-threat-count queen1 (cdr otherqueens)) ; no threats here - continue on
            )
        )
     )
    0 ; (null otherqueens)
   )
)

;;; Helper for heuristic
(defun queens-heuristic-inner (fullstate workingstate)
   (if (not (null workingstate))
       (+ (queens-is-threat-count (car workingstate) (remove-queen fullstate (car workingstate)))
          (queens-heuristic-inner fullstate (cdr workingstate)))
     0
   )
)

;;; Counts up the number of threats between queens on the board (state).
;;; 2 queens threatening one another is counted as 2.
(defun queens-heuristic (futurestate)
   (queens-heuristic-inner futurestate futurestate)  
)

;;; Cost function for n queens.
;;; This calculation is very simple.  Every state change is +1 from the previous cost, which is curcost.
;;; If nil is received as the prevstate, it is assumed that it is the initial state and hence a cost of 0
;;; is returned.
(defun queens-g-cost (curcost prevstate newstate)
   (if (null prevstate)
       0 ; the root node is the only node with prevstate of nil
       (+ curcost 1)
   )
)

;;; Solves then queens 8 problem using a-star-search from package a-star.
;;; There are 3 optional parameters:
;;;  start - The start state to solve the puzzle from.  If start is not specified, *queens-default-start-state* is used.
;;;  print-detail - Boolean indicating whtether all nodes, including those that have not been expanded, are to be printed.  The default is to only print nodes that have been expanded.
;;;     i.e. nodes with children or that are the goal state.
;;;  maxiters - The maximum number of expansions allowed.  The default for this is 1000.
(defun n-queens (&key (start *queens-default-start-state*) (print-detail nil) (maxiters 1000))
   (let ((result (multiple-value-list (a-star:a-star-search maxiters start #'queens-generate-child-states #'queens-heuristic #'queens-g-cost #'queens-get-printable-state))))
      (if (not (second result)) ; 2nd value in response is a boolean indicating whether the goal state was found.
         (format t "~&Failed to solve!")
      )
      (format t "~&TREE:~%")
      (a-star::print-tree (first result) print-detail #'queens-get-printable-state)
   )
)
