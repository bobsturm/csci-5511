;;;; This file contains functions needed to invoke a-star-search on a 3x3 puzzle.
;;;;
;;;; puzzle-search is the function that should be called to solve a puzzle.  Use of the a-star package to run the search requires that we (puzzle-search) provide
;;;; the following functions to encapsulate the behavior of the 3x3 puzzle problem:
;;;;   1) heuristic - A heuristic function that, given a current state and a candidate future state (as generated by generate-child-states), returns a heuristic cost for the potential future state.
;;;;   2) generate-child-states -  A child state generation function that, given a current state, generates all candidate future states that might be chosen as the next state.  This function respects the rules
;;;;       of the 3x3 puzzle search problem.
;;;;   3) g-cost - A cost function that, given the current cost, a current state, and a future state, calculates the total cost of moving from current state to future state.  For puzzle search, this is simple - each 
;;;;       transition increases the total cost by 1.
;;;;   4) state-equal - A state equality function that, given 2 states returns t if those states are equivalent.
;;;;   5) get-printable-state - A print helper function that creates a pretty print string for the given state.
;;;;
;;;;
;;;; Future TODOs that would improve puzzle search: remove hardcoded refs to the board being 3x3 and allow the board to be an arbitrary nxn size.


(in-package :cl-user)

;;; A location on the board, specified by row (i) and column (j)
(defstruct location
  i  ;; number representing row index
  j  ;; number representing column index
)

;;; Creates a puzzle state from the given sequence of numbers.  The numbers 0_0, 0_1, 0_2 represent row 1 in the puzzle, etc.
(defun create-state (0_0 0_1 0_2 1_0 1_1 1_2 2_0 2_1 2_2)
  (list (list 0_0 0_1 0_2) (list 1_0 1_1 1_2) (list 2_0 2_1 2_2))
)

;;; Represents the blank square on the puzzle.
(defparameter *blank-square* 0 "constant representing the blank square")

;;; The goal state when running puzzle search
(defparameter *goal-state* (create-state 1 2 3 4 5 6 7 8 *blank-square*))

;;; This state will be used if no start state is provided when calling puzzle-search
(defparameter *default-start-state* (create-state *blank-square* 1 3 4 2 5 7 8 6))


;;; Returns the number value of the tile (or blank) on the given coordinates
(defun get-loc-value(state i j)
 (nth j (nth i state))
)

;;; Utility function for move
;;; Given a current state (i.e. parent state), a location in that state, and 2 locations that should be swapped (as part of 
;;; moving the blank square) this function determines the value at the new (i.e. child) state.  If 
(defun get-new-value (state loc swaploc1 swaploc2)
   (let ((swap1i (location-i swaploc1))
         (swap1j (location-j swaploc1))
         (swap2i (location-i swaploc2))
         (swap2j (location-j swaploc2))
         (curi (location-i loc))
         (curj (location-j loc)))
            (if (and (equal curi swap1i) (equal curj swap1j)) ; return value at swaploc2
               (get-loc-value state swap2i swap2j)
                  (if (and (equal curi swap2i) (equal curj swap2j)) ; return value at swaploc1
                     (get-loc-value state swap1i swap1j)
                    (get-loc-value state curi curj) ; else just return the current value at loc
               )
         )
    )
)

;;; Utility function for find-loc
;;; Recursive function that finds the given tile in the given state.
;;; Returns a location structure representing the location of the given tile value.
;;; Caller should seed i and j to 0 and 0.
;;; Raises and error if the tile is not found.
(defun find-loc-inner (state tile i j)
   (if (> j 2) (error "TILE NOT FOUND!!")) 

   (if (equal (get-loc-value state i j) tile)
      (make-location :i i :j j)
     (if (< i 2)
         (find-loc-inner state tile (+ i 1) j)
       (find-loc-inner state tile 0 (+ j 1))
     )
   )
)

;;; Given a state and a tile value, returns a location structure
;;; reperesenting the location (i, j coordinates) of the tile.
(defun find-loc (state tile)
   (find-loc-inner state tile 0 0)
)

;;; Given the coordinates, returns a boolean indicating
;;; whether or not the coordinates are legal in a 3x3 puzzle.
(defun is-legal (i j)
  (and (< i 3) (> i -1) (< j 3) (> j -1))
)

;;; Given 2 locations on a puzzle, this determines whether or not the 
;;; move between the locations is legal.  For example, a move from (0, 1) to (1, 2) is not
;;; a legal move in 8 puzzle.
(defun is-legal-move (loc newloc)
  (let 
      ((i (location-i loc)) 
       (j (location-j loc))
       (newi (location-i newloc))
       (newj (location-j newloc)))
       (let ((disti (abs (- newi i)))
             (distj (abs (- newj j))))
             (if (not (is-legal i j)) 
                (error "Invalid loc provided ~S~%" loc)
             )
             (and 
                (is-legal newi newj)
                (or 
                   (and
                      (equal disti 1)
                      (equal distj 0))
                   (and
                      (equal 0 disti)
                      (equal 1 distj))
                 )
             )
      )
   )
)

;;; This print function is used by a-star to print the state of the puzzle.
;;; Given a state, this returns a pretty print representation of the state.
;;; For example:
;;;
;;; "(1 2 3)
;;;  (4 5 6)
;;;  (7 8 0)
;;; "
(defun get-printable-state (s)
   (if (not (null s))
      (let ((row1 (format nil "~S~%" (car s)))
            (remainder  (get-printable-state (cdr s))))
         (if (null remainder)
             row1
                 (concatenate 'string row1 " " remainder)
         )
      )
   )
)

;;; Given a location structure representing the location where the blank square 
;;; should move to, this function creates a new state based on moving the blank square
;;; to that position.
;;; Returns nil if the move is not legal.
(defun move (state newloc)
  (let ((loc (find-loc state *blank-square*)))
     (if (is-legal-move loc newloc)
         (create-state (get-new-value state (make-location :i 0 :j 0) newloc loc)
                       (get-new-value state (make-location :i 0 :j 1) newloc loc)
                       (get-new-value state (make-location :i 0 :j 2) newloc loc)
                       (get-new-value state (make-location :i 1 :j 0) newloc loc)
                       (get-new-value state (make-location :i 1 :j 1) newloc loc)
                       (get-new-value state (make-location :i 1 :j 2) newloc loc)
                       (get-new-value state (make-location :i 2 :j 0) newloc loc)
                       (get-new-value state (make-location :i 2 :j 1) newloc loc)
                       (get-new-value state (make-location :i 2 :j 2) newloc loc))
     )
   )  
)

;;; This function is used by a-star to generate child states from a parent state to keep
;;; the search continuing.
;;; Given a parent state, generates all legal 8-puzzle moves from this state.
;;; A list of the candidate child states is returned.
(defun generate-child-states (parentstate)
       (let ((blankloc (find-loc parentstate *blank-square*))) ; find the blank square and then move it.
         (remove nil (list (move parentstate (make-location :i (- (location-i blankloc) 1) :j (location-j blankloc))) ;; move up
                           (move parentstate (make-location :i (+ (location-i blankloc) 1) :j (location-j blankloc))) ;; move down
                           (move parentstate (make-location :i (location-i blankloc) :j (+ (location-j blankloc) 1))) ;; move right
                           (move parentstate (make-location :i (location-i blankloc) :j (- (location-j blankloc) 1))) ;; move left
                      ) ; removes all nils which means the move was not legal.
         )
       )
)

;;; Utility function for calculating manhattan distance for the (i, j) tile.
;;; If *blank-square* is located at the (i, j) location for from-state, a distance of 0 is returned.
(defun man-distance-filter-blank (i j from-state to-state)
   (if (equal (get-loc-value from-state i j) *blank-square*) 
       0
     (man-distance i j from-state to-state)
   )
)

;;; Calculates the manhattan distance for the tile in the (i, j) position in from-state
;;; to the location of that same tile in to-state.
(defun man-distance (i j from-state to-state)
   (let ((tile (get-loc-value from-state i j)))
      (let ((to-loc (find-loc to-state tile)))
         (+ (abs (- (location-i to-loc) i)) (abs (- (location-j to-loc) j)))
      )
   )
)

;;; Utility function for heuristic.  Sums up the man-distance between the 2 given states: cur and goal.
;;; The *blank-square* is not included in the sum.
(defun heuristic-inner (i j cur goal)
   (if (> j 2)
       0
      (+ 
         (man-distance-filter-blank i j cur goal)
         (if (equal i 2) 
             (heuristic-inner 0 (+ j 1) cur goal)
            (heuristic-inner (+ 1 i) j cur goal)
         )
      )
   )
)

;;; This is the heuristic function for 8-puzzle.  The signature for this method requires a future puzzle state.
;;; This heuristic sums all the manhattan distances for each tile in futurestate from the *heuristic-goal-state* global variable.
;;; The blank square is not added to the sum - only numbers are considered.
(defun heuristic (futurestate)
   (if (null *heuristic-goal-state*)
      (error "The global variable *heuristic-goal-state* must be setup before heuristics can be calculated!")
   )
   (heuristic-inner 0 0 futurestate *heuristic-goal-state*)
)

;;; Cost function for puzzle.
;;; This calculation is very simple.  Every state change is +1 from the previous cost, which is curcost.
;;; If nil is received as the prevstate, it is assumed that it is the initial state and hence a cost of 0
;;; is returned.
(defun g-cost (curcost prevstate newstate)
   (if (null prevstate)
       0 ; the root node is the only node with prevstate of nil
       (+ curcost 1)
   )
)

;;; Given 2 states, returns t if the states are equivalent; nil otherwise.
;;; For puzzle search, this is simply an equalp of the 2 lists.
;;; If nil is passed in for either state, and error is raised.
(defun state-equal (state1 state2)
   (if (not (and (listp state1) (listp state2)))
      (error "Unexpected type received within function ~S" #'state-equal)
         (equalp state1 state2)
   )
)

;;; If the *blank-square* is found in the first row, swap the first 2 tiles in the 2nd row.
;;; Otherwise, swap the first 2 tiles in the first row.
(defun swap-two-tiles (s)
   (let ((blankloc (find-loc s *blank-square*)))
      ; swap on a row that does not contain the *blank-square* to keep things simple.
      (if (equal (location-i blankloc) 0) ; blank in first row.  Swap the first 2 tiles in the second row
          (rotatef (first (second s)) (second (second s))) ; blank not in first row. Rotate the 1st and 2nd element in the first row
        (rotatef (first (first s)) (second (first s)))
      )
      s
   )
)

;;; Solves the 8 puzzle problem using a-star-search from package a-star.  If the puzzle is not solved in maxiters expansions, it is assumed that 
;;; an infeasible state was used for start.  When this happens, the submitted start state is adjusted to a form that is feasible and solved.
;;; NOTE: If maxiters is not high enough to solve a feasible puzzle, start will be adjusted and re-run.  This is detected and "Failed to find goal state again!" is 
;;; printed to the terminal.
;;; The solution is printed after the a-star search completes.
;;; There are 3 optional parameters:
;;;  start - The start state to solve the puzzle from.  If start is not specified, *default-start-state* is used.
;;;  print-detail - Boolean indicating whtether all nodes, including those that have not been expanded, are to be printed.  The default is to only print nodes that have been expanded.
;;;     i.e. nodes with children or that are the goal state.
;;;  maxiters - The maximum number of expansions allowed.  The default for this is 1000.
(defun puzzle-search (&key (start *default-start-state*) (print-detail nil) (maxiters 1000))
   (setq *heuristic-goal-state* *goal-state*) ; Required for heuristic function.
   (if (null start)
       (setq start *default-start-state*)
   )
   (let ((result (multiple-value-list (a-star:a-star-search maxiters start *goal-state* #'generate-child-states #'heuristic #'g-cost #'state-equal #'get-printable-state))))
      (if (not (second result)) ; 2nd value in response is a boolean indicating whether the goal state was found.
          (let ((swapstart (swap-two-tiles start)))
             (format t "Goal State NOT Found! Altering start state slightly to be ~S and rerunning to determine if orignal start state is infeasible" (get-printable-state swapstart))
             (setf result (multiple-value-list (a-star:a-star-search maxiters swapstart *goal-state* #'generate-child-states #'heuristic #'g-cost #'state-equal #'get-printable-state)))
             (if (second result)
                 (format t "Original start state is INFEASIBLE!  Adjusted start state of ~S has been solved!"  (get-printable-state swapstart))
               (format t "Failed to find goal state again!")
             )
          )
      )
      (format t "~&TREE:~%")
      (a-star::print-tree (first result) print-detail #'get-printable-state)
   )
)
